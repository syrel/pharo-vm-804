'From Pharo13.0.0SNAPSHOT of 23 May 2024 [Build information: Pharo-13.0.0+SNAPSHOT.build.68.sha.355c58ea4c282884975d1d6f76cacb7307cad8e7 (64 Bit)] on 23 May 2024 at 3:20:20.756236 pm'!FFILibrary subclass: #Issue804	instanceVariableNames: ''	classVariableNames: ''	package: 'Issue-804'!!Issue804 commentStamp: 'Anonymous 5/23/2024 15:20' prior: 0!A reproducible deadlock example for https://github.com/pharo-project/pharo-vm/issues/804Run:```Issue804 reproduce```!!Issue804 methodsFor: 'accessing - platform' stamp: '5/23/2024 12:19'!unixLibraryName	"Users should use unix32* or unix64*"	^ FFIUnix64LibraryFinder findLibrary: 'libIssue804.so'! !!Issue804 methodsFor: 'accessing - platform' stamp: '5/23/2024 12:19'!macLibraryName	^ FFIMacLibraryFinder findLibrary: 'libIssue804.dylib'! !!Issue804 methodsFor: 'accessing' stamp: '5/23/2024 12:19'!runner	^ TFWorker named: ('Worker {1}' format: { 100 atRandom })! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Issue804 class	instanceVariableNames: ''!!Issue804 class commentStamp: 'Anonymous 5/23/2024 15:20' prior: 0!A reproducible deadlock example for https://github.com/pharo-project/pharo-vm/issues/804Run:```Issue804 reproduce```!!Issue804 class methodsFor: 'issue' stamp: '5/23/2024 15:18'!reproduce	| aSemaphore aSemaphoreIndex aSignalSemaphore aSignalSemaphoreIndex aSignaller aCounter raiseSignalFinished semaphoreSignalFinished |		"Forward SIGUSR1 to a semaphore. For example, a UnixOSSubprocess does the same.	The semaphore will be then signalled using `signalSemaphoreWithIndex` from `aio_handle_events`.	It deadlocks when there is another thread that signals a semaphore during `aio_handle_events`."	aSignalSemaphore := Semaphore new.	aSignalSemaphoreIndex := Smalltalk registerExternalObject: aSignalSemaphore.	self primForwardSignal: self sigUsr1Number toSemaphore: aSignalSemaphoreIndex.	"Define a semaphore to signal from another thread."	aSemaphore := Semaphore new.	aSemaphoreIndex := Smalltalk registerExternalObject: aSemaphore.	aSignaller := ExternalAddress loadSymbol: #signalSemaphoreWithIndex.		"The following will signal a semaphore and raise SIGUSR1 from their own thread"	semaphoreSignalFinished := false.	[		self signalSemaphore: aSignaller index: aSemaphoreIndex times: 10000 delay: 2.		semaphoreSignalFinished := true.		NonInteractiveTranscript  stdout nextPutAll: 'signalSemaphore finished'; cr. ] fork.	raiseSignalFinished := false.	[ self raiseSignal: self sigUsr1Number times: 10000 delay: 2.	NonInteractiveTranscript  stdout nextPutAll: 'raiseSignal finished'; cr.	raiseSignalFinished := true ] fork.		"Print steps as long as signalling threads are running.	Pharo is deadlocked when `Step #i` are no longer printed"	aCounter := 1.	[ semaphoreSignalFinished or: [ raiseSignalFinished ] ] whileFalse: [		semaphoreSignalFinished ifFalse: [			aSemaphore waitTimeoutMilliseconds: 10 ].				raiseSignalFinished ifFalse: [			aSignalSemaphore waitTimeoutMilliseconds: 10 ].				NonInteractiveTranscript stdout			nextPutAll: 'Step #';			nextPutAll: aCounter asString;			cr.		aCounter := aCounter + 1 ]! !!Issue804 class methodsFor: 'accessing' stamp: '5/23/2024 12:19'!ffiLibrary	^ self! !!Issue804 class methodsFor: 'primitives' stamp: '5/23/2024 12:19'!signalSemaphore: aSignaller index: anIndex times: times delay: delay	^ self		ffiCall: #(void signal_semaphore(void* aSignaller, long anIndex, int times, int delay))! !!Issue804 class methodsFor: 'primitives' stamp: '5/23/2024 12:17'!sigUsr1Number	<primitive: 'primitiveSigUsr1Number' module: 'UnixOSProcessPlugin'>		self primitiveFailed! !!Issue804 class methodsFor: 'primitives' stamp: '5/23/2024 12:19'!raiseSignal: aSignal times: times delay: delay	^ self		ffiCall: #(void raise_signal(int aSignal, int times, int delay))! !!Issue804 class methodsFor: 'primitives' stamp: '5/23/2024 12:17'!primForwardSignal: signalNumber toSemaphore: semaphoreIndex	<primitive: 'primitiveForwardSignalToSemaphore' module: 'UnixOSProcessPlugin'>	^ nil! !